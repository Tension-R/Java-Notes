# 泛型程序设计
## 1. 泛型类
- 一个泛型类可以有一种或多种类型变量。

## 2. 泛型方法
- 类型变量放在修饰符后面，返回类型前面。

	 public static < T > T getMiddle(T...a){
		return a[a.length/2];
	}
	
- 泛型方法可以定义在普通类中，也可以定义在泛型类中。

## 3. 类型变量的限定
- 有时需要对类型变量加以约束

	public static < T extends ×××> T min {...}
- 只能使用extends关键字。
- 一个类型变量或通配符可以有多个限定，限定类型用&分隔。

## 4.泛型代码和虚拟机
- 虚拟机没有泛型类型，自动提供了一个相应的原始类型。
- 原始类型用第一个限定的类型变量替换，如果没有限定类型就用Object替换。
- 翻译泛型表达式时，编译器会自动插入强制类型转换。
- 桥方法被合成来保持多态。

## 5. 约束和局限性
- 不能用基本类型替代实例化类型参数。
- 运行时查询只适用于原始类型，instanceof，类型转换都不能用泛型，反射得到的类名也是原始类型。
- 不能实例化参数化类型的数组，如 
	
    `Pair<String>[] tale = new Pair<>[10]; //ERROR`
    
    可以声明类型为`Pair<String>[]`的变量，但是不能实例化：`new Pair<String> [10]`。
- 如果要收集参数化类型对象，安全有效的方法是使用ArrayList<>。
- 不能实例化类型变量。
- 不能在静态域或方法中引用类型变量。
- 不能抛出或捕获泛型类实例，泛型类不能扩展Throwable。
- 一个类不能实现同一个接口的不同参数化。

## 6. 通配符
- `Pair<? extends Employee>`
- `Pair<? super Manager>`
- 带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取。