# 多线程
## 1. 线程状态
- New（新创建）
- Runnable（可运行）
- Blocked（被阻塞）
- Waiting（等待）
- Timed waiting（计时等待）
- Terminated（被终止）
- 调用getState方法确定一个线程的状态。

### 1. 新创建线程
- 使用new操作符创建一个新线程，该线程还没开始运行。它的状态是new。

### 2. 可运行线程
- 调用start方法之后，线程处于runnable状态。
- 正在运行中的线程仍然处于可运行线程。
- 一个可运行的线程可能正在运行，也可能没有运行。

### 3. 被阻塞线程和等待线程
- 当一个线程试图获取对象锁时，线程进入阻塞状态。
- 当线程等待另一个线程通知调度器一个条件时，自己进入等待状态。

### 4. 被终止的线程
- 因为run方法正常退出而自然死亡。
- 因为一个没有捕获的异常终止了run方法而意外死亡。

## 2. 线程属性
### 1. 线程优先级
- java中每个线程都有一个优先级。
- 默认情况下，一个线程继承它父线程的优先级。
- 可以使用setPriority方法提高或降低任何一个线程的优先级。
- 可以将优先级设置为在MIN_Priority与MAX_PRIORITY之间的任何值，默认为NORM_PRIORITY：5。

### 2. 守护线程
- 可以调用setDaemon(true)将线程转换为守护线程。
- 守护线程的唯一用途时为其他线程提供服务。例如计时线程，定时发送“计时器滴答”信号给其他线程或清空过时的高速缓存项的线程。
- 当只剩下守护线程时，虚拟机就退出了。

### 3. 未捕获异常处理器
- 调用setUncaughtExceptionHandler方法为任何一个线程安装一个处理器。
- 调用setDefaultUncaughtExceptionHandler为所有线程安装一个默认的处理器。
- 如果不安装默认处理器，默认的处理器为空，但是如果部位独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象。
- 建议不要在自己的程序中使用线程组。

## 3. 同步
### 1. 锁对象
- synchronize关键字，自动提供一个锁以及相关的“条件”。
- ReentrantLock保护代码块的基本结构：

```java
myLock.lock();
try{
	...
}finally{
	myLock.unlock();
}
```
保证任何时刻只有一个线程进入临界区，其他线程调用lock时将会被阻塞，知道第一个线程释放锁对象。
- 锁是可重入的，线程可以重复的获得已经持有的锁。锁保持一个持有计数来跟踪对lock方法的嵌套调用。
- 被一个锁保护的代码可以调用另一个使用相同锁的方法。

### 2. 条件对象
- 使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程。
- 一个锁对象可以有一个或多个相关的条件对象。
- 可以使用newCondition方法获得一个条件对象。
- 调用await()方法使线程阻塞，并放弃锁。
- 调用signalAll方法重新激活因为条件而等待的所有线程。
- 调动signal方法随机解除等待集中某个线程的阻塞状态。

### 3. synchronized关键字
- 锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码。
- 锁可以管理试图进入被保护代码段的线程。
- 锁可以拥有有一个或多个相关的条件对象。
- 每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程。
- 如果一个方法用synchronized关键字声明，那么对象的锁将保护整个方法。要调用该方法，线程必须获得内部的对象锁。
- 每一个java对象都有一个内部锁。
```java
public synchronized void method(){
	...
}
```
等价于
```java
public void method(){
	this.intrinsicLock.lock();
	try{
    	...
 	} finally {
       	this.intrinsicLock.unlock();
 	}
 }
 ```
- 内部对象锁只有一个相关条件。wait方法添加一个线程到等待集中，notifyAll/notify方法解除等待线程的阻塞状态。
- 内部锁和条件存在一些局限
	- 不能中断一个正在试图获得锁的线程。
	- 试图获得锁时不能设定超时。
	- 每个锁仅有单一的条件，可能不够。

### 4. 监视器
- 监视器是只包含私有域的类。
- 每个监视器类的对象有一个相关的锁。
- 使用该锁对所有的方法进行加锁。
- 该锁可以有任意多相关条件。

### 5. volatile域
- volatile关键字为实例域的同步访问提供了一种免锁机制，如果声明一个域为volatile，那么编译器和虚拟机就知道该域可能被另一个线程并发更新。
- volatile变量不能提供原子性。

### 6. 锁测试与超时
- tryLock方法试图申请一个锁，在成功获得锁后返回true，否则立即返回false，线程可以立即离去做其他事。
- tryLock方法可以使用超时参数。
- 等待一个条件时，也可以提供一个超时参数。

### 7. 读/写锁
- 构造一个ReentrantReadWriteLock对象。
- 抽取读锁和写锁。
- 对所有获取方法加读锁。
- 对所有修改方法加写锁。

## 4. 线程安全的集合
### 1. 高效的映射表、集合和队列
- ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet和ConcurrentLinkedQueue。
- 任何类都可以通过使用同步包装器变成线程安全的。
	- `List<E> synchArrayList = Collections.synchronizedList(new ArrayList<>());`