# 集合
## 1.集合接口
- 集合接口与实现相分离。
- 可以用for each简练的循环集合。
- 迭代器查找一个元素的唯一方法是调用next。
- 应当器在两个元素中间，当调用next时，迭代器越过一个元素，并返回刚刚越过的那个元素的引用。
- 想要删除指定位置的元素，依然需要先越过这个元素。
- 集合初始化元素要在迭代器声明之前。

## 2. 具体集合
### 1. 链表
- Java中链表是双向链接的，每个节点还存放着指向前驱节点的引用。
- 链表增加删除一个元素很轻松，只需修改需要改动的元素附近的节点。
- ListIterator中有
	- add方法，在迭代器之前增加元素。
	- previous方法，向前越过元素，
- add方法只依赖迭代器位置，remove方法依赖于迭代器状态（next/previous）。
- set方法用一个新元素替代迭代器刚越过的元素。
- 链表不支持快速随机访问，要查看第n个元素就要从头开始，越过n-1个元素。
- 链表依然提供了get方法，但是效率很低，非常不建议使用，如有用到建议修改数据结构。
- list.listIterator(n)将返回一个迭代器，这个迭代器指向索引为n的元素前面的位置。
- nextIndex方法返回下一次调用next时，要越过元素的索引值。
- previIndex方法返回下一次调用previous时，要越过元素的索引值。

### 2. 数组列表
- ArrayList访问节点效率很高，插入删除节点效率很低。
- ArrayList方法不是同步的。

### 3. 散列集
- 散列表用链表数组实现，每个列表被称为桶。要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，得到的结果就是保存这个元素的桶的索引。
- 如果桶被占满，发生散列冲突，需要用新对象与桶中所有对象比较，查看这个对象是否已经存在。
- 如果散列表太慢，就需要再散列，需要创建一个桶数更多的表，并把所有元素插入到新表中，丢弃原来的表。
- 装填银子决定何时对散列表散列，一般装填银子0.75比较合理。
- 散列将元素分散在表的各个位置，所以访问他们的顺序几乎时随机的。

### 4. 树集
- 树集是一个有序集合，可以以任意顺序将元素插入到集合中。
- TreeSet实现了SortedSet接口
- 排序用红黑树实现。
- 将一个元素添加到树要比添加到散列表慢，但是，比把一个元素添加到数组或链表的正确位置快很多。
- 可以构造一棵带有比较器的树。
- TreeSet实现了NavigableSet接口，增加了几个便于定位元素以及反向遍历的方法。

### 5. 双端队列
- 可以有效地在头部和尾部同时添加或删除元素。
- 不支持在队列中添加元素。
- remove方法，poll方法删除并返回队列头部元素。
- element方法，peek方法返回队列头部元素。

### 6. 优先级队列
- 优先级队列中的元素可以按照任意顺序插入，却总是按照排序的顺序检索。
- 优先级队列使用了堆的数据结构，堆是一个可以自我调整的二叉树，对树执行添加删除操作，可以让最小的元素移动到根。

### 7. 映射表
- 存放键值对。
- 散列映射表对键进行散列。
- 树映射表用键的整体顺序对元素进行排序，并将其组织称搜索树。
- 散列或比较函数只能作用于键，与键关联的值不能进行散列或比较。
- 键必须是唯一的，不能同一个键存放两个值。
- 如果对一个键两次调用put方法，第二个值会取代第一个值，put将返回这个键存储的上一个值。
- `Set<K> keySet()`方法可以获取键集（无重复）。
- `Collection<V> values()`方法可以获取值的集合（可能有重复）。
- `Set<Map.Entry<Integer,String>> entrySet()`方法可以获取键值对集。
- 如果两个对象的键不同，值相同，视为同一个对象（equals方法返回true）。

### 8. 专用集与映射表类
#### 1. 弱散列映射表
- 一种值无用武之地后可以被垃圾回收器回收的映射表。
- WeakHashMap用弱引用保存键，弱引用对象将引用保存到另一个对象中。
- 如果某个对象只能由弱引用引用，垃圾回收期就会回收，但要将引用这个对象的弱引用放入队列中，WeakHashMap周期性的监察队列，以便找出新添加的弱引用。

#### 2. 链接散列集和链接散列表
- LinkedHashSet和LinkedHashMap用来记住插入元素项的顺序。

#### 3. 枚举集与映射表
- EnumSet是一个枚举类型元素集的高效实现。内部用位序列实现，如果对应的值在集中，则相应的位置被置为1.
- EnumSet类没有公共构造器，可以使用静态工厂方法构造这个集。
- EnumMap是一个键类型为枚举类型的映射表，它可以直接且高效的用一个值数组实现。

#### 4. 标识散列映射表
- IdentityHashMap，这个类中，键的散列值不是用hashCode计算的，而是用System.identityHashCode计算的。根据对象的内存地址来计算散列码时所使用的方式。
- 比较两个对象时用==不用equals。
- 不同的键对象，即使内容相同，也被视为不同的对象。

## 3. 集合框架
- 集合有两个基本接口：Collection和Map。
- 有一个标记接口RandomAccess，这个接口没有方法，但是可以检测一个特定集合是否支持高效的随机访问。用instanceof方法（ArrayList和Vector实现了这个接口）。

### 1.视图和包装器
- 映射表类的keySet方法
	- 不是创建了一个新集，把映射表中的键都填进去，返回这个集。
	- 而是返回一个实现Set接口的类对象，这个类的方法对元映射表进行操作。这种集合称为视图。

#### 1.轻量级集包装器
- Arrays类的静态方法asList将返回一个包装了普通Java数组的List包装器，而不是返回一个ArrayList对象。它是一个视图对象，带有访问底层数组的get，set方法。但是所有改变数组大小结构的方法都会抛出异常。
- asList是一个具有可变数量参数的方法，还可以把元素直接传递给这个方法。
- 调用Collections.nCopies(n, anObject)方法时，将返回一个实现了List接口的不可修改的对象，并给人一种包含了n个元素，每个元素都是一个anObject的错觉。
- 调用Collections.singleton(anObject)方法，将返回一个实现了Set接口的不可修改的氮元素及，不需要付出建立数据结构的开销。
- singletonList方法与singletonMap方法类似。
#### 2. 子范围(subrange)视图
- 可以使用subList获取列表的子范围视图。

	`List group2 = staff.subList(10,20); // 10-19`
- 可以将任何操作应用于子范围，并且能够自动反应整个列表情况。（删除）

#### 3. 同步视图
- synchronizeMap方法可以将任何一个映射表转换为具有同步访问方法的映射表。

#### 4. 检查视图
- 检查视图用来对泛型类型发生问题时提供调试支持。
- 视图的add方法将检测插入的对象是否属于给定的类。

#### 5. 集合与数组的转换
- 数组转换集合可以直接使用Arrays.asList()方法。
- 集合转换数组
	- toArray方法只能长生一个Object类型数组，不能强制转换。
	- 与需要使用toArray(new String[0]);方法，也可以构造一个指定大小的数组。
