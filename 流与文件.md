# 流与文件
## 1. 流
### 1. 读写字节
- InputStream有一个抽象方法
	- abstract int read()
- 这个方法读入一个字节，并返回读入的字节，或者在遇到输入源结尾时返回-1。
- read和write方法在执行时都将阻塞，直至字节确实被读入或写出。
- available方法可以用来检查当前可读入的字节数量。
- 完成读写时应该调用close方法关闭。
- 可以用flush方法冲刷输出流的缓冲区，把所有缓冲区的字符都输出。

### 2. 组合流过滤器
- java可以将多种流的构造器进行组合，形成一个有多重功能的流。

### 3. 文本输入与输出
- 可以使用PrintWriter输出文本，还有一个将PrintWriter链接到FileWriter的便捷方法。
		PrintWriter out = new PrintWriter(new FileWriter("***"));
- 若果写出器设置为自动冲刷模式，只要println被调用，缓冲区所有字符都会被发送到目的地。
- 以二进制格式写出数据，需要使用DataOutputStream。
- 以文本格式写出数据，需要使用PrintWriter。

### 4. 读写二进制文件
- DataInputStream/DataoutputStream

### 5. 随机访问文件
- RandomAccessFile类可以在文件中的任何位置查找或写入数据 。

## 2. ZIP文档
- 使用ZipInputStream来读入ZIP文档。
- 需要浏览文档的每一个单独项时，getNextEntry方法可以返回一个描述这些项的ZiEntry类型的对象。
- 必须调用closeEntry来读入下一项。
- 使用ZipOutputStream写出到ZIP文件中。
- 对于希望放入到ZIP文件中的每一项，都应该创建一个ZipEntry对象，并将文件名传递给ZipEntry的构造器，它将设置其他诸如文件日期，解压缩方法等参数。也可以覆盖这些设置。
- 必须调用closeEntry来读入下一项。

## 3. 对象流与序列化
- 希望在对象流中存储或恢复的所有类都必须实现Serializable接口。
- 每个对象都用一个序列号保存，算法如下：
	- 遇到的每一个对象引用都关联一个序列号。
	- 对于每个对象，第一次遇到时，保存其对象到流中。
	- 如果某个对象之前被保存过，那么只写出“与之前保存过的序列号为x的对象相同”。在读回对象时，整个过程反过来。
	- 对于流中的对象，第一次遇到其序列号时，构建它，并使用流中数据来初始化它，然后记录这个顺序号和新对象之间的关联。
	- 当遇到“与之前保存过的序列号为x的对象相同”标记时，获取与这个序列号相关联的对象引用。

### 1. 对象序列化的文件格式
- 对象流输出中包含所有对象的类型和数据域。
- 每个对象都被赋予一个序列号。
- 相同对象的重复出现将被存储为对这个对象的序列号的引用。

### 2. 修改默认的序列化机制
- 某些数据与不可被序列化，例如，只对本地方法有意义的存储文件句柄或窗口句柄的整数值，这种信息在稍后重新加载或将其传送到其他机器上时都没有用处。如果这种域的值不恰当，还会引起本地方法崩溃。
- 把它们标记为transient时，它们将不会被序列化。

### 3. 版本管理
- 如果一个类具有名为serialVersionUID的静态数据成员，序列化系统就可以读入这个类的对象的不同版本。
- 如果这个类只有方法发生了变化，那么读入新对象数据时不会有问题。
- 如果这个类的数据域发生了变化，那么读入新对象时可能会有问题。
- 对象流会将这个类当前版本和流中版本的数据域进行比较，如果两部分数据域名字匹配而类型不匹配，对象流不会尝试将一种类型转换为另一种类型，因为两个对象不兼容。
- 如果流中对象有当前版本中没有的数据域，那么对象流会忽略这些额外的数据。
- 如果当前版本对象有在流中对象没有的数据域，那么对象流会把它们设置为默认值。

### 4. 为克隆使用序列化
- 直接将对象序列化到输出流中，然后将其读回。这样产生的新对象是对现有对象的一个深拷贝。
- 这个方法比显示的构建新对象并赋值或克隆数据域的克隆方法慢很多。

## 4. 操作文件
### 1. Path类
- 静态的Path.get方法接受一个或多个字符串，并将它们用默认文件系统的路径分隔符连接起来。
- get方法可以获取包含多个部件构成的单个字符串。
- resolve方法可以解析路径，resolve方法可以接受一个字符串而不是路径。
- resolveSibling方法解析指定路径的父路径产生其兄弟路径。
- relativize方法产生路径

## 5. 缓冲区数据结构
- 缓冲区是由具有相同类型的数值构成的数组。
- 最常用的是ByteBuffer和CharBuffer。
- 每个缓冲区都具有：
	- 一个容量，永远不能改变。
	- 一个读写位置，下一个值将在此进行读写。
	- 一个界限，超过它进行读写没有意义。
	- 一个可选标记，用于重复一个读入或写出操作。
- 这些值满足条件：
	- 0 <= 标记 <= 读写位置 <= 界限 <= 容量

## 6. 文件加锁机制
- 可以调用FileChannel类的lock或tryLock方法对文件加锁。
- 可以调用FileLock lock/tryLock(long start, long size, boolean shared)方法锁定文件的一部分。
- 如果shared标志为false，则锁定文件的目的时读写。
- 如果为true，则是一个公共锁，允许多个进程从文件中读入，并组织任何进程获得独占锁。
- 如果锁定了文件的尾部，而这个文件的长度随后增长超过了锁定的部分，那么增长出来的额外区域是不锁定的。要锁定所有字节，可以使用Long.MAX_VALUE来表示尺寸。
- 要确保在操作完成时释放锁，最好在try语句中执行释放锁的操作。
- 文件加锁机制依赖于操作系统。
